// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package mp2.ng.hw.Battleship;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.Stack;
import java.util.function.BiConsumer;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.function.Function;

import javax.management.RuntimeErrorException;
import javax.sound.midi.Track;

import mp2.ng.hw.Battleship.Cell;
import mp2.ng.hw.Battleship.Ship;

/************************************************************/
/**
 * 
 */
public class Field {
	public static final int FIELD_SIZE = 10;
	public static final int SHIPS_TOTAL = 10;
	protected static final int[] SHIP_SET = { 0, 4, 3, 2, 1 };

	public enum Dir {
		LEFT, RIGHT, UP, DOWN
	}

	public enum AtackResult {
		MISS, HIT, SANK, WIN
	}

	/**
	 * 
	 */
	private List<Ship> ships;
	/**
	 * 
	 */
	private Cell[][] cells;

	// trials allowed for function placing ships
	// probability to fail placing is < 10e-9, using 36 trials
	private static int trialsAllowed = 36;

	// the variables for tests
	private static int maxTrialsOccured = 0;
	private static int totalTrialsOccured = 0;

	private static int trialsAddBrickSum;
	private static int trialsAddBrickCount;

	public Field() {
		buildField();
	}

	public void buildField() {
		cells = new Cell[FIELD_SIZE][FIELD_SIZE];
		ships = new ArrayList<>();
		for (int i = 0; i < FIELD_SIZE; i++) {
			for (int j = 0; j < FIELD_SIZE; j++)
				cells[i][j] = new Cell(i, j);
		}
	}

	// ships placing
	public void populate() {
		TryPopulate:
			while (!Thread.currentThread().isInterrupted()) {

				for (int i : SHIP_SET) {
					for (int j = 0; j < SHIP_SET[i]; j++) {
						Ship ship = placeShip(i);
						if (ship != null)
							ships.add(ship);
						else {// clean up and repeat
							buildField();
							continue TryPopulate;
						}
						
						// ships.add(Objects.requireNonNull(placeShip(i),
						// "Ship wasn't created. size " + i + " No " + j));
					}
				}
				if (!checkNeighbourhood())
					throw new RuntimeErrorException(new Error("Field wasn't populated properly"));
				break TryPopulate;
			}
	}

	public Ship placeShip(int shipSize) {
		Ship probableShip = new Ship(shipSize);

		NextPosition:
			for (int trials = 0; trials < trialsAllowed; trials++) {
			totalTrialsOccured++;
			if (trials > maxTrialsOccured)
				maxTrialsOccured = trials;
			// recover after failed trial
			probableShip.cells.forEach(Cell::removeShip);
			probableShip.cells.clear();

			for (int bricksPlaced = 0; bricksPlaced < shipSize; bricksPlaced++) {
				if (!tryAddBrick(probableShip))
					continue NextPosition;
			} // if all bricks have been placed then enough trials
			break NextPosition;
		}
		if (probableShip.cells.size() < shipSize) {
			probableShip.cells.forEach(Cell::removeShip);
			return null;
		}
		surroundShip(probableShip);
		return probableShip;
	}

	public boolean tryAddBrick(Ship probableShip) {
		trialsAddBrickCount++;
		Random random = new Random();
		int y;
		int x;
		// if this is the 1st brick, generate position to try near it
		if (probableShip.cells.isEmpty()) {
			// System.err.println("tryAddBrick: O new ship!");
			y = random.nextInt(10);
			x = random.nextInt(10);
			// else try near previously placed brick
		} else {
			y = probableShip.cells.getLast().y;
			x = probableShip.cells.getLast().x;
		}
		// try to add brick to the ship in one of 4 allowed positions
		// chances not to try one of cases: (1 - 1/4)^15 ~ 1.3%
		for (int trials = 0; trials < 15; trials++) {
			trialsAddBrickSum++;
			int nextY = y;
			int nextX = x;
			Dir where = Dir.values()[random.nextInt(4)];
			switch (where) {
			case LEFT:
				nextX--;
				break;
			case RIGHT:
				nextX++;
				break;
			case UP:
				nextY--;
				break;
			case DOWN:
				nextY++;
				break;
			}
			if (isACell(nextY, nextX) && !cells[nextY][nextX].isAShip() && !cells[nextY][nextX].isSurround()) {
				probableShip.cells.add(cells[nextY][nextX]);
				cells[nextY][nextX].setShip(probableShip);
				// System.err.println("tryAddBrick: That took " + (trials + 1) +
				// " trials");
				return true;
			}
		}
		return false;
	}

	public void surroundShip(Ship probableShip) {
		probableShip.cells.forEach(c -> {
			int y = c.y;
			int x = c.x;
			for (int i = y - 1; i <= y + 1; i++) {
				for (int j = x - 1; j <= x + 1; j++)
					if (isACell(i, j) && !cells[i][j].isAShip()){
						cells[i][j].setSurround(true);
						probableShip.surround.add(cells[i][j]);
					}	
			}
		});
	}

	//game process
	public AtackResult surviveBombardment(int x, int y) {
		Cell cell = cells[y][x];
		cell.beenBombed();
		if (!cell.isAShip())
			return AtackResult.MISS;
		Ship ship = cell.ship;
		if (ship.surviveBombardment(cell))
			return AtackResult.HIT;
		ships.remove(ship);
		if (!ships.isEmpty())
			return AtackResult.SANK;
		
		return AtackResult.WIN;
	}
	
	//system
	public String renderForAlly() {
		StringBuilder result = new StringBuilder(this.toString());//TODO
//		result.
		String str = this.toString().replaceAll("S", " ").replaceAll("_", " ");
		result.toString();
		return result.toString();
	}
	
	public String renderForEnemy() {
		return this.toString().replaceAll("[0-9]", " ").replaceAll("_", " ");
	}
	//utils
	private void applyToCell(int x, int y, boolean value, Consumer<Boolean> f) {
		if (isACell(x, y))
			f.accept(value);
	}

	private boolean isACell(int x, int y) {
		return (x >= 0 && x < FIELD_SIZE) && (y >= 0 && y < FIELD_SIZE);
	}

	private Cell getCell(int x, int y) {
		if (isACell(x, y))
			return cells[x][y];
		else
			return null;
	}

	@Override
	public String toString() {
		StringBuilder field = new StringBuilder();
		for (Cell[] i : cells) {
			field.append(Arrays.deepToString(i) + '\n');
		}
		return field.toString();
	}
	
	public String print() {
		StringBuilder field = new StringBuilder();
//		field.append 
//		(Arrays.deepToString(i) + '\n');
		for (Cell[] i : cells) {
			for (Cell c : i) {
				field.append(c.isAShip()?1:0);
			}
			field.append('\n');
		}
		return field.toString();
	}

	public int countShipedCells() {
		int countCells = 0;
		for (Cell[] cc : cells)
			for (Cell c : cc)
				if (c.isAShip())
					countCells++;
		return countCells;
	}

	public int countSurroundCells() {
		int countCells = 0;
		for (Cell[] cc : cells)
			for (Cell c : cc)
				if (c.isSurround())
					countCells++;
		return countCells;
	}

	public int countWasShipCells() {
		int countCells = 0;
		for (Cell[] cc : cells)
			for (Cell c : cc)
				if (c.isWasShip())
					countCells++;
		return countCells;
	}

	public boolean checkNeighbourhood() {
		for (Ship s : ships) {
			for (Cell c : s.cells) {
				int y = c.y;
				int x = c.x;
				for (int i = y - 1; i <= y + 1; i++)
					for (int j = x - 1; j <= x + 1; j++)
						if (isACell(i, j) && cells[i][j].isAShip() && cells[i][j].ship != s)
							return false;
			}
		}
		return true;
	}

	public static int getTrialsAllowed() {
		return trialsAllowed;
	}

	public static void setTrialsAllowed(int trialsAllowed) {
		Field.trialsAllowed = trialsAllowed;
	}

	public static int getMaxTrialsOccured() {
		return maxTrialsOccured;
	}

	public static void resetMaxTrialsOccured() {
		maxTrialsOccured = 0;
	}

	public static int getTotalTrialsOccured() {
		return totalTrialsOccured;
	}

	public static void resetTotalTrialsOccured() {
		Field.totalTrialsOccured = 0;
	}

	public static int getTrialsAddBrickSum() {
		return trialsAddBrickSum;
	}

	public static int getTrialsAddBrickCount() {
		return trialsAddBrickCount;
	}

	public static void testPopulate(int points, int runs) {
		System.out.println("\n populate test");
		Field field = new Field();
		int maxTrials = 50;
		long[] totalFails = new long[maxTrials];
		int[] totalTrials = new int[maxTrials];
		for (int k = 0; k < points; k++) {
			for (int j = 0; j < maxTrials; j++) {
				Field.setTrialsAllowed(j);
				for (int i = 0; i < runs * 1000; i++) {
					field = new Field();
					try {
						field.populate();
					} catch (Exception e) {
						totalFails[j]++;
					}
				}
				totalTrials[j] += Field.getTotalTrialsOccured();
				Field.resetTotalTrialsOccured();
			}
		}

		synchronized (checkPoint) {
			checkPoint += Thread.currentThread().getName();
			System.out.println("\n totalFails");
			Arrays.stream(totalFails).forEach(n -> System.out.print(n / (points * runs) + " "));
			System.out.println("\n totalTrials");
			Arrays.stream(totalTrials).forEach(n -> System.out.print(n / (points * runs) + " "));

			System.out.println("\n avgTrials");
			Arrays.stream(totalTrials).forEach(n -> System.out.print(n / (points * runs) + " "));

			System.out.println("\n max add trials " + Field.getTrialsAddBrickCount() + " "
					+ (double) Field.getTrialsAddBrickSum() / Field.getTrialsAddBrickCount());
		}
		// IntStream.range(0, maxTrials).forEach(i ->
		// System.out.print(totalTrials[i] / totalSucceed[i]));
	}

	static String checkPoint = "complete ";

	public static void main(String[] args) throws InterruptedException {
		// Thread tr1 = new Thread(() -> testPopulate(12,12), "tr1");
		// Thread tr2 = new Thread(() -> testPopulate(12,12), "tr2");
		// System.out.println("start");
		// tr1.start();
		// tr2.start();
		Field field  = new Field();

		
		System.out.println(field);
		System.out.println(field.renderForAlly());
		System.out.println(field.renderForEnemy());
		
		Random random = new Random();
		int y;
		int x;

			int i = 0;
		for ( i = 0; field.ships.size() > 7; i++) {
			y = random.nextInt(10);
			x = random.nextInt(10);
			field.surviveBombardment(x, y);
		}
		System.out.println("7 ships left after " + i);
		System.out.println("\n" + field.renderForAlly());
		System.out.println("\n" + field.renderForEnemy());
	}

}
